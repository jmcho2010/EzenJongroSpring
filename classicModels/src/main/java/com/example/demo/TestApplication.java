package com.example.demo;

import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

import jakarta.servlet.http.HttpSession;

@SpringBootApplication
public class TestApplication {

	public static void main(String[] args) {
		SpringApplication.run(TestApplication.class, args);
	}

	// 캐릭터들이 살만한 꽃동네를 생성(스프링 빌리지)
	//  -> 주민 한명 입주(급하냥)
	// 급하냥의 역할 : 마을의 입구에서 방문객들의 요청을 가장먼저 받아 처리하는 역할
	//   -> 컨트롤러를 좀 돌려얘기해봄
	
	// 시나리오
	// 방문객이 옴.(http://localhost:8080/test1)
	// 마을 입구에서 이것을 확인한 급하냥은 즉시 요청을 접수.
	// 성격이 급한 급하냥은 신속하게 처리하기 위해 미리 준비해둔 test.html을
	// 방문객에게 보여줌(view단 호출)
	// 방문객은 응답으로 test.html파일을 볼수 있음
	
	// 시나리오2
	// 생각보다 스프링빌리지에 방문객이 많아졌음
	// 방문객들이 많아지다 보니 서로 소식을 전할 주민 게시판 요청이 들어옴.
	// 급하냥(컨트롤러)의 업무부담 증가.
	//  -> 급하냥 혼자서 게시판을 만들고 관리하려니까 너무 힘듬.
	//  -> 환영인사에만 집중하고 글을 받아서 내용을 분석하고 창고에 안전하게
	//      보관하는 일까지 하기위한 전문가를 초빙.
	
	// 급하냥은 자신의 일을 도와줄 두명의 전문가 친구를 초빙.
	// 와플곰 : 요청의 핵심을 파악하고 실질적인 업무를 처리하는 서비스 전문가(@Service)
	// 카피바라 : 데이터를 창고에 안전하게 보관하고 꺼내오는 담당자
	//   -> DB에 안전하게 보관하고 꺼내오는 데이터 전문가.
	
	// 사실 이 모든일들은 급하냥(컨트롤러)이 혼자 처리하는거 가능.
	//  -> 하지만 급하냥, 와플곰, 카피바라가 각자 영역들을 문제없이 처리해 준다면
	//     더 효율적인 업무처리가 가능.
	
	//  -> 어디든 운영을 할때 덩치(체급)이 커지면 관리자, 실무자 등등 구분하는것처럼
	//     스프링에서도 컨트롤러 서비스 db 등을 각자 분할하여 처리.
	
	// 시나리오 3
	// 페이지 상세보기, 게시글 수정, 삭제.
	
	// 급하냥(컨트롤러)이 여태껏 보여줬던건 게시글 전체 내용일뿐
	//  -> 정해진 주소로 오는 요청만 처리.
	// 상세 보기가 필요해진 지금 주소 자체에 정보가 담겨오는 요청도 처리할필요가 있음.
	//  -> URL에 포함된 숫자를 정확히 파악하여 서비스단(와플곰)에 요청을 넘겨줄거임
	//     (와플곰아 1번 게시글 가져와줘), 2,3번도 유동적으로 사용자에 요청에따라 
	//      처리할수 있음.
	
	// 시나리오 4
	// 회원가입, 로그인, 로그아웃 구현하기.
	// 여기저기 몰려와서 방명록 남기고 그러다보니 조금더 체계적인 관리를 진행할필요가 생김
	// 정식으로 등록된 주민(사용자), 방문객을 구분할 예정
	// 주민들에게만 특정한 권한을 부여할 예정. -> 이런것들을 처리하기위해 스프링 시큐리티 도입.
	
	// 시큐리티 시스템은 두가지의 핵심적인 일을 진행함.
	//  -> 시큐리티는 경비견 누렁이가 담당할거임.
	
	// 1. 인증(Authentication) : 멍멍 신분증 보여주개!
	//  - 마을(스프링 시스템)에 들어오려는 사람이 누구인지 확인하는 과정.
	//  - 사용자가 아이디와 비밀번호를 제출(로그인)하면 누렁이가 
	//     db에 등록된 정보와 일치하는지 확인.
	
	// 2. 인가(Authorization) : 마을사람이지만 여기는 출입 통제 구역이개.
	//  						여기는 프라이빗 룸이개.
	//  - 신원이 확인된 사람이라 해도 모든것을 할수 있는게 아니다 라는 얘기.
	//  - 해당 행동에 대한 권한이 있는지를 확인하는 과정.
	//  - 예를들어 게시글 작성은 주민등급만 가능하고 마을 관리는 마을 이장 등급만 가능하도록 설정.
	
	// 과거에는 이런것들을 코딩하려면 개발자가 직접 체계를 잡아 쿠키와 세션관리를
	// 일일히 해줘야 했기때문에 개복잡.
	
	// -> 최근에는 스프링 시큐리티를 활용하여 쿠키 세션관리 및 회원 가입등을 쉽게
	//    처리할수 있도록 시큐리티의 도움을 받는 추세.
	
	// 당장 시큐리티로 뭐할거임?
	// 회원가입, 로그인, 로그아웃 기능 처리.
	
	// 에러가 났을때는 어떻게 대처해야하는가?
	// 1. 에러 메세지부터 찾아야함.
	// 2. 에러 메세지를 기반으로 아는거면 해결
	//     -> 모르는거먼 서칭해야함.
	// 3. 원인 찾았으면 테스트.
	
	// Bean 객체
	//  -> 개발자가 직접 정의한 메서드들을 스프링이 시작될때 자동으로 올리도록 유도하는 객체.
	//      ( 스프링 컨테이너에 빈으로 등록하도록 지정하는 역할)
	//  -> Bean 객체는 스프링(컨테이너)에 의해 생성되고 관리된다.
	//  -> Bean 객체의 경우는 사용자의 url 요청시 불러질수도 있지만.
	//     정확히는 특정한 상황에서 요청이 없더라도 불러지는 메서드 혹은 객체라 할수있음.
	//  쉽게 얘기하자면 spring의 static
	
	// 시나리오 5
	// 댓글달기.
	// 공지용이 아니라 활발한 커뮤니티성 페이지로 진화.
	// 관계설정
	// 댓글기능을 추가.
	// 게시글과 댓글의 관계를 어떻게 설정하느냐
	// 하나의 게시글은 여러개의 댓글을 가질수 있음.
	// 하나의 댓글이 여러개의 게시글을 가질수 있나요?(x)
	//  -> 즉 게시글과 댓글은 순서대로 표기하자면 1:N 이라는 관계설정이 필요.
	
	// 시나리오 6
	// 댓글 수정, 삭제하기
	//  -> 댓글은 인증된 사용자들만 댓글을 쓸수 있도록 처리.
	//  -> 인가는?(로그인한 사용자들만 댓글을 쓰는것 자체가 인가처리도 완료)
	//  -> 댓글을 쓰는것은 인증된 사용자들만 댓글을 쓰는게 맞음.
	//     하지만 댓글의 수정은? -> 당연히 쓴사람만 가능해야하지 않을까?
	//  -> 댓글 삭제는? -> 마찬가지 아닌가?
	//  로그인한 사용자가 이 댓글을 직접 쓴사람이 맞는지를 확인하는 작업이
	//  앞으로는 필요할것이다. (권한확인)
	
	// 시나리오 7
	// 공손한 따봉(추천)
	// 사용자, 게시글
	//  -> 한명의 사용자가 여러개의 게시글을 작성할수 있음.
	// 예시 상황
	//  -> 사용자 1이 게시글을 보고 추천버튼을 클릭.
	//  -> 컨트롤러(급하냥)가 이것을보고 게시글에대한 추천요청이 도착했고
	//     요청자는 유저 1이야 라고 와플곰에게 전달.
	//  -> 서비스(와플곰)은 추천 명단을 확인후  없다면 추천처리 완료 메세지를 전달.
	//     repo로 넘겨야함.
	
	// 시나리오 8
	// 파일업로드
	// 사용자들에게 자기 자신을 표현할수 있는 방안을 확장하거나
	// 혹은 적절한 이미지를 업로드함으로써 시스템(서비스)를 더 효율적이고
	// 혹은 상품판매에 유리함을 가져가도록 설계할수 있음.
	// 왠만한 웹 서비스에서는 파일업로드 기능은 필수.
	//  -> Stream, 폼에 대해서도 변경이 필요.
	// 특히 파일업로드 다운로드 기능 구현에는 경로 설정과 저장공간에 대한 이해도가 필수.

	// 1. 템플릿 - 폼에 MultipartFile이라는 객체에 담하서 전송.(컨트롤러/급하냥)
	//    - 이 객체 안에는 파일의 원본이름, 크기, 내용물등의 정보를 흔히 담음.
	
	// 2. 컨트롤러에서는 이 내용을 서비스로 잘만 던져주면됨.
	//    -첨부파일의 처리는 흔히 서비스단에서 하거나 혹은 파일관련 메서드를 따로만들어 처리.
	//    -파일을 외부에서 받아올때는 바이트 코드 타입으로 가져옴 -> (물리적파일)원본 파일로 변경
	//    - 파일을 저장할때는 다른사용자와 같은이름의 파일일수 있기때문에 
	//      원본의 이름을 따로 저장한후 고유한 이름을 새로 만들어 저장하는것이 안전.
	//    - 저장을 하려면 서버의 특정 폴더로 이동.
	//      ( 엔티티는 아무것도 안해도됨? - 서버에 저장된 파일의 경로와 고유한 파일이름을 받아야함.)
	//    - 브라우저(크롬)가 저장된 이미지를 화면에 보여주려면 서버는 특정한 URL로
	//      요청이 왔을때 실제 파일 저장폴더에서 해당파일을 찾아 보내주는 역할을 해야함.
	//      -> 기준은 서버에 저장되어있는 파일의 위치 (정적 리소스 매핑)
	
	// 시나리오 9
	// 정규표현식(Regular Expression)과 유효성 검사(Validation check).
	
	// 유효성 검사 : 사용자 혹은 받아온 데이터가 적합한지 검증하는 검사 방식.
	//  -> 사용자가 내용을 입력했는데 이게 우리 서비스 기준에 맞게 제대로 입력했는지 확인.
	
	// 여태 이런거 없이 잘했는데?
	//  -> 지금까지는 사실 쓰는 사람들이 우리들밖에 없었음. 근데 만약 이 서비스가
	//     외부에 호스팅되는 상황이었다면?
	//  -> 무의미한 데이터들로 우리의 데이터베이스가 가득차버릴수 있음. 
	//     혹은 이런 상황때문에 무의미한 시스템 에러가 발생할수도 있음.
	
	// 의존성 추가로 다음의 라이브러리가 필요 
	// implementation 'org.springframework.boot:spring-boot-starter-validation'
	// BindingResult와 principal을 잘 이용하면 간단하게 강력한 유효성 검사를 만들수도 있음.
	
	// 유효성검사를 통해 우리 시스템에 맞는 올바른 데이터들만 다루도록 진행
	
	// 정규표현식 : 유효성 검사로 처리하기 어려운 양식들을 처리해줄수 있는 일종의 탐지기.
	//  -> 특정한 규칙을 가진 문자열을 찾아내거나 바꾸거나 분리하기 위해 사용하는
	//     문자열 형식의 공식. 
	
	// 전화번호를 예를들면 '-'을 쓰는 사람이 있고 안쓰는 사람이 있음.
	//  -> 하지만 전원 전화번호를 입력한건 맞지만 컴퓨터의 입장은?
	
	// 정규표현식으로 할수 있는것들
	// 전화번호 검증, 이메일 검증, 주민번호 검증 등등
	//  -> 일정한 형식을 가진 모든 텍스트를 검증할수 있음.
	
	// 정규표현식의 기본 문법.
	// . : 아무 문자 하나와 일치.
	// * : 앞의 문자가 0번 이상 반복
	// + : 앞의 문자가 1번 이상 반복
	// ? : 앞의 문자가 0번 혹은 1번 나타남.
	// [] : 괄호 안의 문자 중 하나와 일치.
	// ^ : 문자열의 시작과 일치
	//    -> ^안녕  : 안녕 이라는 단어로 시작하는 문자열을 찾아주세요.
	//       안녕하세요 : 통과, 하이 안녕하세요 : x
	// $ : 문자열의 끝과 일치. 
	//     -> 안녕$ : 안녕 이라는 단어로 끝나는가? 
	// \d : 숫자 하나와 일치 [0-9]
	//      -> 영문자[a-z], [A-Z]
	//      -> 한글 [가-힣]
	// \w : 문자 하나와 일치(숫자, 알파벳, _)
	// \s : 공백 하나와 일치(스페이스, 탭, 줄바꿈)
	// {n} : 앞의 문자가 정확히 3번 반복
	//  ex) \d{3} : 숫자 3개.
	// {n,m} : 앞의 문자가 n번 이상 m번 이하 반복
	//  ex) \w{2,5} : 문자 2~5개.
	
	// 정규표현식 활용 패턴.
	// 이메일 정규표현식 패턴. 
	// ^ : 문자열이 뒤의 대괄호 패턴으로 시작해야함을 의미. 
	// [a-zA-Z0-9] : 영문 대소문자 + 숫자 허용
	//  ._%+- <-- 대괄호 내부에 있으면 이런 특수문자 사용을 허용하겠다는 의미. 
	// + : 이 패턴이 한번 이상 반복될수 있음을 의미.
	// @ : 이메일이니까 이메일을 구분하는 로컬 / 도메인 파트
	// \\ : 도메인 명과 최상위 도메인을 구분하는 . 자체를 표현
	// -> 
	// {2,6} : 최소 2글자에서 최대 6글자까지의 길이를 허용.
	//  $ : 표현식 끝
	// 아래의 패턴이 깰라면 충분히 깰수는 있음
	// test@test. <-----
	
//	String regExp = "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,6}$";
//	//자바 기준으로 정규표현식을 활용하기 위해서는
//	// Pattern, Matcher라는 클래스를 활용해서 처리할 필요가 있음.
//	Pattern p1 = Pattern.compile(regExp);
//	
//	String test1 = "nureong@gmail.com";
//	String test2 = "wafflegom@";
//	
//	// 입력받은 이메일에 대해 Matcher 클래스를 통해 검사.
//	Matcher m1 = p1.matcher(test1);
//	
//	// 정규표현식을 기반으로 검사하는 메서드. 
//	if(m1.matches()) {
//		System.out.println("합격이에용");
//	}
	
	//String recipe = "비밀 반죽: [밀가루] 500g과 [계란] 3개, 그리고 약간의 [사랑]을 넣고 섞어주세요.";
	
	// [가-힣] : 한글들만 뽑아 내겠다.(한글 글자 하나하나)
	// () : 캡처 그룹생성 (정규표현식에서 일치하는 부분을 추출할수 있도록 해주는 파트
	// [] <---- 
	// \\[ <--- 정규표현식에서 대괄호는 특별한 의미가 있음.
	//   그래서 이스케이프 코드를 통해 말그대로 문자 [의 시작을 찾겠다는 의미
	// 결론 : 대괄호 안에 있는 한글들을 추출해주세요!
//	Pattern pattern = Pattern.compile("\\[([가-힣]+)\\]");
//	Matcher matcher = pattern.matcher(recipe);
//	
//    List<String> ingredients = new ArrayList<>();
//    // find(): 패턴과 일치하는 다음 부분을 찾으면 true 반환
//    while (matcher.find()) {
//        // group(1): 첫 번째 괄호 그룹에 해당하는 내용("밀가루", "계란", "사랑")을 가져옴
//        ingredients.add(matcher.group(1));
//    }	
	
	
//	급하냥의 임무: "고객 후기 게시판에 전화번호(010-1234-5678)나 "
//			+ "이메일(loopy@village.com) 같은 개인정보가 그대로 노출되면 큰일 나! "
//			+ "전화번호는 가운데 4자리를 '***'로, 이메일은 아이디 앞 3글자 빼고 "
//			+ "전부 ''로 바꿔주는 자동 마스킹 시스템을 만들어줘! 빨리!"
	
//	String review = "배송 최고예요! 제 번호는 010-1234-5678 이고, "
//			+ "이메일은 loopy@village.com 입니다. 연락주세요!";
//	
//	String phoneReg = "(\\d{3})-(\\d{4})-(\\d{4})";
//	// replaceAll : 정규표현식을 사용하여 텍스트 내의 특정 패턴을 찾아 변경.
//	// $1 : phoneReg<--- 이 변수에서 첫번째 그룹인 d{3}에 해당하는 부분을 가져옴.
//	String maskedReview = review.replaceAll(phoneReg, "$1-****-$3");
//	
//	
//	String regExp = "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,6}$";
//    String emailRegex = "([a-zA-Z0-9]{4})([a-zA-Z0-9]+)(@[a-zA-Z0-9.-]+\\.[a-zA-Z]+)";
//    maskedReview = maskedReview.replaceAll(emailRegex, "$1****$3");
	
	// 정규표현식 결론
	//  -> 몰라도 코딩하는데 조금 불편할순 있지만 지장은 없음.
	//  -> 근데 익숙해지면 텍스트 작업은 겁나빠르게 처리할수있음.
	
	// 시나리오 10
	// 페이징처리(기존시나리오 페이징처리는 폐쇄)
	// 페이지 : 가상의 메모리를 동일한 크기의 블록으로 나눈 단위. 
	// 페이징 : CS에서 사용하는 메모리 관리 기법. 
	//  -> OS가 프로세스에서 사용하는 메모리를 효율적으로 관리하기위해 사용하는 방법.
	
	// 페이징처리 : UI에 표현되는 대량의 데이터를 차근차근 나누어 처리하기위해 사용하는 기법.
	//  -> 단순하게 화면에 적절히 표현한다의 문제를 넘어서 서버의 부하나 사용자가 활용할 장치의
	//     부담도 줄일수 있다. 
	
	
	// 페이징은 도서관과 비유해보면 이해가 쉬워짐
	// 도서관 전체 = 데이터베이스에 저장된 데이터.
	// 한 책장(서가) = 한 페이지에 보여줄 데이터. 
	// 도서관 안내원 = Pageable 객체.
	// 책장 목록표 Page 객체. 
	
	// 급하냥, 와플곰, 카피바라(JPA 명세 기술을 사용해서 데이터를 요청받은대로만 정확하고 빠르게 찾아줌)
	// 
	
	// 시나리오 11
	// REST API(RESTful을 추구해야하는게 맞긴한데...)
	// API의 내부 구조.
	// 클라이언트가 우리 API 주소(URL)를 찾아온 상황.
	//  -> 그렇다면 해당 주소를 가진 메서드(API)는 뭘 줘야하지?
	//  -> 기본적으로는 어떠한 데이터를 돌려줄지를 고민해봐야한다.
	//  -> 프로토콜상 요청과 응답으로 넘기고 받아오는 레시피가 있음
	//     (JSON, YAML)
	
	// JSON(JavaScript Object Notation) 
	//  - 데이터를 저장하고 교환하기위한 텍스트 기반의 경량 데이터 교환 형식
	//  - 사람이 읽을 수 있고 시스템에서 구문을 분석할수 있는 방식으로 설계.
	
	//  - 다양한 프로그래밍 언어에서 활용가능
	//  - 가벼움(과거에는 XML을 이용 -> 하지만 JSON은 XML보다 간결하고 가볍다)
	//  - XML은 읽는게 개빡쳤음.
	//  - XML에 비하면 JSON은 k-v 형태로 구성되어 있어서 인간 친화적.
	//  - 텍스트 기반의 전송
	//    (모든 데이터가 텍스트 형식으로 저장되어있기 때문에 네트워크 전송에 적합)
	
	// JSON의 기본 문법과 구조.
	// 숫자, 문자, boolean, 배열, 객체, null
	
	// 문법 규칙
	// 1. 데이터는 k-v 형태로 표현한다
	// 2. 키값은 반드시 문자열로 작성한다.("")
	// 3. 데이터는 콤마로 구분한다.
	// 4. 객체는 중괄호로 배열은 대괄호로 표현한다.
	
	// JSON 사용처
	// 서버와 클라이언트간의 데이터 교환에 가장 많이 사용.(API)
	// 설정정보 저장시(YAML)
	
	// YAML(YAML Ain't Markup Language)
	//  -> 데이터 중심의 언어임을 강조하기 위해.
	//  확장자가 .yml, yaml
	
	// JSON의 완전 상위호환.
	//  -> 대체 가능할 정도.
	
	// 설정이나 문서화 작업에 많이 사용.
	
	// 시나리오 12
	// 요청받은 데이터를 잘 던지기위한 API 구축 및 
	// DB와의 연동을 하는 방법을 알아보기.
	
	// 영속성 컨텍스트 
	//  -> 엔티티를 영구 저장하는 환경.
	//  @Transactional 어노테이션이 붙어 있다면 메서드가 시작될때 생성되고
	//   메서드가 끝날 때 사라지는 논리적인 공간임.
	// 영속성 컨텍스트 법칙 4가지
	// 1차 캐시 : 영속성 컨텍스트는 내부에 Map 형태의 캐시를 가지고있음
	//  -> 여기서 key는 엔티티에 선언된@ID의 값이되고
	//     value는 엔티티 객체 그 자체가 value로 묶이게된다.
	//  -> findById 같은 조회를 진행하면 JPA가 이 엔티티를 1차 캐시 영역에 저장.
	//  -> 만약 동일한 ID로 다시 조회를 요청하면 JPA는 DB에 굳이 요청하지 않고
	//     저장된 엔티티를 리턴. 
	//  -> 불필요한 DB 조회가 줄어들다보니 성능 향상에 큰 도움이 된다.
	// 동일성 보장
	//  -> 똑같은 요청이 들어오면 몇번을 호출하던지 완벽하게 동일한 객체 인스턴스를 
	//     리턴하는것을 보장. (일관성을 보존)
	// 쓰기지연(Transactional Write-behind)
	//  -> save 메서드가 호출되어도 JPA는 즉시 INSERT SQL을 DB로 보내지 않음.
	//  -> 생성된 SQL을 SQL 쓰기 지연 저장소 라는 내부 공간에 차곡차곡 모아둠.
	//     트랜잭션 커밋이 발동하는 순간 지연저장소에 모아둔 SQL들을 한번에 DB로 전송.
	//  -> IDENTITY가 걸려있을 경우는 트랜잭션 상관없이 SAVE 동작하는순간 바로 저장.
	// 변경 감지 : 엔티티 상태만 변경하면 DB 업데이트도 알아서!
	//  -> 자동업데이트.
	
	// 엔티티의 생명주기(라이프 사이클)
	// 1. 비영속 : 객체 생성만 된 상태 DB와는 무관한 상태 new Entity()
	// 2. 영속 : save. findById 같은 메서드들을 통해 영속성 컨텍스트 라는것의 
	//          관리를 받게된 상태.
	// 3. 준영속 : 영속성 컨텍스트가 관리하던 엔티티였으나 컨텍스트가 종료되거나
	//            개발자가 특정한 메서드를 호출하여 더이상관리하지 않는 상태.
	//            -> 변경감지나 지연로딩같은 기능들을 활용할수 없음.
	// 4. 삭제 : 삭제요청이 진행된 상태.
	
	// 실전에서는 어떻게 쓰일까?
	// 앞서 언급한 내용들은 @Transactional로 감싸진 범위 내에서만 일어난다는점.
	// 특히나 변경감지는 트랜잭션이 끝나고 커밋될때 동작함. 
	//  -> 가급적이면 데이터의 수정이 포함된 로직은 반드시 @Transactional 어노테이션이
	//     붙은 서비스 메서드 내부에서 처리하는것이 좋다.
	
	// 그래서 현업은 조회할때도 DTO를 잘 쓰는게 보안상으로도 굉장히 유리.
	//  -> 다만 데이터 수정시에는 DTO로 객체 내용들 받아다가 원본 엔티티로
	//     동작시켜서 변경 감지 기능의 동작을 유도하는 방안도 나쁘지 않음.
	
	// 연관 데이터가 필요할 경우에는 FetchJoin이라는 속성을 활용해야함.
	
	// 시나리오 12는 아직 끝나지 않음. 지속적으로 활용할 예정.
	 
	// 시나리오 13
	// 시큐리티의 전체 구조 파악과 OAuth2, JWT -> 구글, 카카오 로그인
	
	// 시큐리티의 흐름
	//  -> Thread : 프로세스 내에서 실행되는 작업 단위.
	//  -> 프로세스와 스레드의 관계 : 하나의 프로세스가 여러개의 스레드를 갖는 구조.
	
	// 스프링과 스레드. 
	// 스프링에서는 일반적으로 요청당 스레드(Thread-Per-Request)를 활용하는 편.
	//  -> 클라이언트의 요청마다 별도의 스레드가 생성이된다 생각하면 편함.
	//  -> 각 요청들은 각각의 독립된 스레드에서 처리되다보니 
	//     동시에 여러 요청들을 병렬로 처리할수 있다.
	
	// 스프링에서는 스레드마다 고유한 데이터를 가지기위해 사용하는 클래스가 있음
	//  -> ThreadLocal 이라 부름
	
	// ThreadLocal : 각 스레드가 고유한 값을 가질 수 있도록 하는 메커니즘.
	//  -> 스레드마다 독립적인 변수를 저장하고 접근할수 있게한다. 
	//  -> 각 요청들이 독립된 스레드에서 처리되다보니 요청간에 공유되지않고 독립적인
	//     데이터를 유지할 필요가 있음.
	//  -> 스레드 관리 클래스라 생각하면 편함. 
	//     (특정 스레드와 관련된 상태를 저장하기 위해 사용)
	//  -> 클래스의 private static 필드로 사용되는 경우가 많음.
	
	
	// 근데 시큐리티랑 뭔 관계?
	// 시큐리티는 ThreadLocal 기반으로 흐름을 제어한다.
	//  -> 시큐리티가 꼭 ThreadLocal을 써야하나?
	// 1. 스레드를 독립적으로 다룰수 있기 때문.
	//  -> 다른 스레드로 부터 접근될 위험이 없어진다. 
	// 2. 독립적으로 활용되다보니 쉽게 접근해서 인증정보를 불러오는것도 가능하지만
	//    반대로 요청처리가 끝나면 쉽게 인증정보를 제거하는것도 가능하다는점.
	
	// 쉽게 비유하자면 
	// 비밀 결사대(클럽)에 가입한다 쳐보겠음.
	//  -> 보안. 은밀하게 아무나 접근하면 당연히 안됨. 아무나가 접근을 시도하면 멍석말이. 
	//  -> 스레드를 파견된 요원.
	//  -> SecurityContextHolder(요원들 개인 사물함)
	
	// 요청시작 -> 인증성공 -> 작업수행 -> 요청종료
	// 1. 요원 A가 클럽에 들어오면 SecurityContextHolder 가 요원A에게만 열리는 사물함을줌
	//    (요청시작)
	// 2. 문지기가 요원 A의 신원을 확인후 그의 신분증(Authentication)을 발급해 사물함에 넣어줌
	//    (인증성공)
	// 3. 요원들은 작업을 수행할수 있고 언제나 신분증을 사물함에서 꺼내 보여줄수 있음.
	//     -> 하지만 이론상으로 그 누구도 다른요원들은 요원 A의 사물함을 열수 없다.
	//        (다른 요청이나 스레드들은 이 스레드로 접근하는것이 이론상 불가)
	//    (작업수행)
	// 4. 요원 A가 클럽을 떠나면 사물함은 즉시 사라짐
	//    (요청 종료)
	
	// 추가설명
	// HTTP Request
	
	// 1. SecurityContextHolder 는 기본적으로 아래의 클래스를 사용한다.
	//   -> ThreadLocalSecurityContextHolderStrategy
	
	// 어려우면 일단 이거부터 생각하자.
	// 시큐리티컨텍스트 전체를 하나의 클럽이라 생각하고 전체적인 클럽의 보안 흐름을 정리.
	// 손님 도착 -> 신원 확인 -> 들어온 사람에 대해 안내인 배정
	//  -> vip인지 아닌지 명단 조회 -> 신원 증명 -> 권한 심사 -> 출입 허가.
	
	// HTTP 요청 확인 -> AuthenticationManager가 심사 
	// -> ProviderManager가 적절한 AuthenticationProvider를 선택.
	// -> UserDetailsService에서 명단 조회(회원정보검색) 
	// -> Authentication 객체 생성 및 SecurityContext에 저장
	// -> AccessDecisionManager가 접근 권한 확인 -> 최종적으로 작업 접근 허용/거부
	 
	// 시큐리티의 인증 처리
	//  -> 원래는 서블릿이 처리해야하지만 시큐리티가 요청을 받아오는거임.
	//     시큐리티의 의존성 주입이 처리되는 순간부터 서블릿에서 시큐리티로 요청에대해 위임해버림.
	//     (DelegatingFilterProxy)
	//  -> FilterChainProxy 라는 녀석이 적절한 SecurityFilterChain을 찾아서 실행.
	//     (CSRF 토큰도 여기서 탐지)
	//  -> 체인을 통해 다음필터로 전달을 요청.
	
	// 필터의 실행 순서
	// 1. SecurityContextHolderFilter 
	//    -> 요청이 시작되면 SecurityContext를 복원, 그리고 끝날때까지 저장.
	// 2. CsrfFilter
	//    -> CSRF 공격 방어 및 토큰 검증
	// 3. LogoutFilter
	//    -> 세션정리와 로그아웃 요청처리. 대기타고있다가 로그아웃하면 정리.
	// 4. UsernamePasswordAuthenticationFilter 
	//    -> Form 로그인 인증 처리.
	// 5. FilterSecurityInterceptor 
	//    -> URL 패턴별 접근권한 검사.(인가)
	
	// HttpServletRequest : 요청에대한 정보를 담고있는 객체
	//  -> 서블릿이라는것에서 제공되는 인터페이스인데 클라이언트가 요청을 보낼때
	//     서버 측에서 해당 요청의 정보를 처리하기위해 사용하는 객체.
	//  -> 컨트롤러 파라미터 영역에 선언후에 사용하면 요청에 들어오는 정보들을 확인할수 있음
	
	// 사용 예시
//	String val = req.getParameter("subject");
//	String usr = req.getHeader("User-Agent");
//	StringBuffer url = req.getRequestURL();
//	String method = req.getMethod(); // get, post 방식 구분
//	HttpSession session1 = req.getSession(); // 전체 세션정보
//	// ip 정보 가져오기
//	String cliIp = req.getRemoteAddr();
	
	
	
	// UsernamePasswordAuthenticationFilter의 상세한 동작원리(시큐리티 기본 로그인 처리과정)
	// 1. 로그인 요청 감지(어디선가 POST 방식으로 시큐리티에서 설정한 /login 요청을 감지한 경우)
	//    -> 언급한 요청이 감지되는순간 UsernamePasswordAuthenticationFilter가 스틸함.
	// 2. HttpServletRequest에서 username과 password 파라미터를 추출해냄.
	// 3. 인증 토큰 생성.
	//    -> UsernamePasswordAuthenticationToken(unauthenticated) 객체를 생성
	// 4. AuthenticationManager 호출 : 생성된 토큰을 AuthenticationManager로 전달.
	// 5. Provider위임 : ProviderManager가 적절한 AuthenticationProvider를 찾아
	//                  인증을 위임.
	// 6. 사용자 조회 : DaoAuthenticationProvider가 UserDetailService를 호출하여 
	//                사용자 정보를 조회.
	// 7. 비밀번호 검증 : 사용자가 입력한 비밀번호와 저장된 비밀번호의 비교
	// 8. 인증완료 : 성공시 인증된 Authentication 객체를 SecurityContext에 저장.
	
	// OAuth2(Open Authorization 2.0)
	//  - 현대적 인증 권한 부여 프레임워크
	//  - 사용자가 자신의 자격증명(id, pw)을 직접 제공하지 않고도
	//    제 3자 어플리케이션(서비스)에 접근할수 있도록 허용하는 개념.
	//  - 사용자는 자신의 계정을 보호, 서비즈 제공가는 안전하게 데이터를 공유할수 있음.
	
	//  - 서비스마다 일일히 계정정보를 입력해 회원가입하는것은 너무 귀찮다.
	//  - 그래서 믿을수 있는 대형 플랫폼의 계정정보를 입력받아 회원가입을 대체하고
	//    로그인을 처리할수 있도록 지원.
	//  - 요약해서 얘기해보자면 옆동네 회원증이 있어도 우리서비스 이용가능해요 라는 개념.
	
	// OAuth2의 주요 개념.(구성요소)
	// 1. Resource Owner
	// 2. Client
	// 3. Authorization Server
	// 4. Resource Server
	
	// OAuth2의 동작방식(주요흐름)
	// 1. 권한요청(플랫폼(소셜)로그인 버튼 클릭)
	// 2. 사용자 승인
	// 3. 인증 토큰 발급(엑세스 토큰 발급)
	// 4. 해당 플랫폼과의 토큰교환(데이터 접근)
	// 5. 사용자 정보 조회.
	// 6. 문제없으면 로그인 처리.
	
	// 소셜 프로바이더별 특징
	// 1. 구글
	//    - 안정적, 구축도 쉬움
	// 2. 카카오
	//    - 국내서비스 한정으로는 굉장히 친화적, 구축이 생각보다 까다로움, 프로필 이미지 지원
	// 3. 네이버
	//    - 카카오보다는 사용빈도가 생각보다 높진않지만 그래도 안정적
	// 4. 깃허브
	//    - 개발자 커뮤니티라던지 개발자들을 위한 플랫폼에 많이 사용하는편
	//      이메일의 별도 권한 요청을 받아야하는 불편함이 있음. 
	
	
	// JWT(JSON Web Token) : 또다른 인증 토큰 
	// UPA기반의 토큰이 일반 쿠키라 치면 JWT는 한번 굽고나면 누가 만들었는지 언제 만들었는지
	// 누구것인지 모든 정보가 쿠키안에 새겨져있어서 위조가 불가능한 쿠키 같은 느낌.
	
	// JWT는 해당 서비스 한정으로는 인증에 대해서는 지속적으로 유지가 가능.
	
	// JWT 구조도 
	// 1. Header(라벨층) : 토큰의 타입과 서명 알고리즘을 명시.
	//     - HMAC SHA-256(HS256)
	// 2. Payload(속재료층) : 사용자의 정보와 사용자의 정보를 설명하는 메타데이터를 포함.(클레임)
	//     2-1 Registered Claims : JWT 표준에서 정의된 클레임(iss, sub, exp 등등)
	//     2-2 Public Claims : URI 형식으로 정의된 공개 클레임
	//     2-3 Private Claims : 서버와 클라이언트 간 합의된 비공개 클레임.
	//     주의사항 : JWT 토큰을 발급할때 민감정보는 Payload에 절대로 담아선 안됨.
	// 3. Signature(서명층) : Header + Payload -> 결합후 비밀키로 서명한 값.
	//     -> 위변조 방지용 + 무결성 보장용
	//     -> 서명된 내용을 원래 데이터로 되돌리는것은 거의 불가능.
	//     -> 그래서 같은 데이터와 키로 다시 서명을 생성한 후에 비교하는 방식을 사용.
	
	// 고대 유물코드 과거에는 요청과 응답을 이런식으로 처리했고
	// 보안회사의 경우는 아직도 서블릿을 깊게활용하여 처리.
//	public class MyServlet extends HttpServlet {
//	    @Override
//	    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
//	        // 요청 파라미터 가져오기
//	        String name = request.getParameter("name");
//
//	        // 헤더 정보 가져오기
//	        String userAgent = request.getHeader("User-Agent");
//
//	        // 세션 가져오기
//	        HttpSession session = request.getSession();
//
//	        // 응답 작성
//	        response.setContentType("text/html");
//	        response.getWriter().println("<h1>Hello, " + name + "</h1>");
//	        response.getWriter().println("<p>Your User-Agent: " + userAgent + "</p>");
//	    }
//	}	
	
	
	
	
	
	
}
